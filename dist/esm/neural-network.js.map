{"version":3,"file":"neural-network.js","sources":["../../../src/matrix.ts","../../../src/nn.ts"],"sourcesContent":["export class Matrix {\n    columns: number\n    rows: number\n    data: number[][]\n\n    constructor(rows: number, columns: number, seed: number = 0) {\n        this.rows = rows\n        this.columns = columns\n        this.data = new Array(this.rows).fill(0).map(() => new Array(this.columns).fill(seed))\n    }\n\n    static fromArray(input_array: any): Matrix {\n        const rows = input_array.length\n        const cols = input_array[0].length || 1\n        const matrix = new Matrix(rows, cols)\n\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < cols; c++) {\n                matrix.data[r][c] = cols === 1 ? input_array[r] : input_array[r][c]\n            }\n        }\n\n        return matrix\n    }\n\n    static toFlatArray(m: Matrix): number[] {\n        let arr = []\n        for (let r = 0; r < m.rows; r++) {\n            for (let c = 0; c < m.columns; c++) {\n                arr.push(m.data[r][c])\n            }\n        }\n        return arr\n    }\n\n    randomise() {\n        this.data = this.data.map((column) => column.map(() => Math.random() * 2 - 1))\n    }\n\n    scale(mod: number) {\n        this.data = this.data.map((column) => column.map((cell) => (cell *= mod)))\n    }\n\n    add(mod: number | Matrix) {\n        this.data = this.data.map((column, ridx) =>\n            column.map(\n                (cell, cidx) => (cell += mod instanceof Matrix ? mod.data[ridx][cidx] : mod),\n            ),\n        )\n    }\n\n    subtract(mod: number | Matrix) {\n        this.data = this.data.map((column, ridx) =>\n            column.map(\n                (cell, cidx) => (cell -= typeof mod === 'number' ? mod : mod.data[ridx][cidx]),\n            ),\n        )\n    }\n\n    static subtract(a: Matrix, b: Matrix) {\n        if (a.rows !== b.rows && a.columns !== b.rows) {\n            console.error('columns must match columns')\n            return undefined\n        }\n        const result = new Matrix(a.rows, a.columns)\n        for (let r = 0; r < result.rows; r++) {\n            for (let c = 0; c < result.columns; c++) {\n                result.data[r][c] = a.data[r][c] - b.data[r][c]\n            }\n        }\n        return result\n    }\n\n    static multiply(a: Matrix, b: Matrix): Matrix {\n        if (a.columns !== b.rows) {\n            console.error('columns must match columns')\n            return undefined\n        }\n\n        const result = new Matrix(a.rows, b.columns)\n\n        for (let r = 0; r < result.rows; r++) {\n            for (let c = 0; c < result.columns; c++) {\n                let sum = 0\n                for (let k = 0; k < a.columns; k++) {\n                    sum += a.data[r][k] * b.data[k][c]\n                }\n                result.data[r][c] = sum\n            }\n        }\n        return result\n    }\n\n    multiply(mod: Matrix) {\n        for (let r = 0; r < this.rows; r++) {\n            for (let c = 0; c < this.columns; c++) {\n                this.data[r][c] *= mod.data[r][c]\n            }\n        }\n    }\n\n    static map(m: Matrix, func: (cell: number) => number): Matrix {\n        const result = new Matrix(m.rows, m.columns)\n        result.data = m.data.map((column) => column.map((cell) => func(cell)))\n        return result\n    }\n\n    map(func: (cell: number) => number) {\n        this.data = this.data.map((column) => column.map((cell) => func(cell)))\n    }\n\n    static transpose(m: Matrix) {\n        const result = new Matrix(m.columns, m.rows)\n        for (let r = 0; r < m.rows; r++) {\n            for (let c = 0; c < m.columns; c++) {\n                result.data[c][r] = m.data[r][c]\n            }\n        }\n        return result\n    }\n\n    transpose() {\n        const result = new Matrix(this.columns, this.rows)\n        for (let r = 0; r < this.rows; r++) {\n            for (let c = 0; c < this.columns; c++) {\n                result.data[c][r] = this.data[r][c]\n            }\n        }\n        return result\n    }\n\n    copy(): Matrix {\n        const newM = new Matrix(this.rows, this.columns)\n\n        for (let r = 0; r < this.rows; r++) {\n            for (let c = 0; c < this.columns; c++) {\n                newM.data[r][c] = this.data[r][c]\n            }\n        }\n\n        return newM\n    }\n\n    //istanbul ignore next\n    print = () => console.table(this.data)\n\n    static deserialise(data: { rows: number; columns: number; data: number[][] }) {\n        let m = new Matrix(data.rows, data.columns)\n        m.data = data.data\n        return m\n    }\n}\n","import { Matrix } from './matrix'\n\nconst sigmoid = (x: number) => 1 / (1 + Math.exp(-x))\n\nconst dsigmoid = (x) => x * (1 - x)\n\nexport class NeuralNetwork {\n    inputs: number\n    hiddenLayerArray: number[]\n    hiddenLayerCount: number\n    outputs: number\n    learningRate: number\n\n    generatedHidden: Matrix\n    generatedOutputs: Matrix\n    weights_ih: Matrix\n    weights_ho: Matrix\n    bias_h: Matrix\n    bias_o: Matrix\n\n    hiddenLayers: Matrix[] = []\n    weights: Matrix[] = []\n    biases: Matrix[] = []\n\n    // constructor(inputs: number, hiddenLayer: number, outputs: number) {\n    //     this.inputs = inputs\n    //     this.hiddenLayer = hiddenLayer\n    //     this.outputs = outputs\n    //     this.learningRate = 0.1\n\n    //     this.weights_ih = new Matrix(hiddenLayer, inputs)\n    //     this.weights_ho = new Matrix(outputs, hiddenLayer)\n    //     this.weights_ih.randomise()\n    //     this.weights_ho.randomise()\n\n    //     this.bias_h = new Matrix(hiddenLayer, 1)\n    //     this.bias_o = new Matrix(outputs, 1)\n    //     this.bias_h.randomise()\n    //     this.bias_o.randomise()\n    // }\n\n    constructor(inputs: number, hiddenLayers: number[], outputs: number) {\n        this.inputs = inputs\n        this.hiddenLayerArray = hiddenLayers\n        this.hiddenLayerCount = hiddenLayers.length\n        this.outputs = outputs\n        this.learningRate = 0.2\n\n        this.weights.push(new Matrix(hiddenLayers[0], inputs))\n        this.weights[0].randomise()\n\n        for (let i = 0; i < hiddenLayers.length; i++) {\n            if (i + 1 < hiddenLayers.length) {\n                this.weights.push(new Matrix(hiddenLayers[i + 1], hiddenLayers[i]))\n                this.weights[i + 1].randomise()\n            }\n            this.biases.push(new Matrix(hiddenLayers[i], 1))\n            this.biases[i].randomise()\n        }\n\n        this.weights.push(new Matrix(outputs, hiddenLayers[hiddenLayers.length - 1]))\n        this.weights[this.weights.length - 1].randomise()\n        this.biases.push(new Matrix(outputs, 1))\n        this.biases[this.biases.length - 1].randomise()\n\n        this.weights_ho = new Matrix(outputs, hiddenLayers[hiddenLayers.length - 1])\n        this.weights_ho.randomise()\n\n        this.bias_o = new Matrix(outputs, 1)\n        this.bias_o.randomise()\n    }\n\n    // train(input_array: number[], targets: number[]) {\n    //     const guess: number[] = this.feedForward(input_array)\n    //     const inputsM = Matrix.fromArray(input_array)\n    //     const guessM: Matrix = Matrix.fromArray(guess)\n\n    //     const targetsM: Matrix = Matrix.fromArray(targets)\n\n    //     //Output gradients\n    //     const output_errors: Matrix = Matrix.subtract(targetsM, guessM)\n\n    //     const output_gradients = Matrix.map(this.generatedOutputs, dsigmoid)\n    //     output_gradients.multiply(output_errors)\n    //     output_gradients.scale(this.learningRate)\n\n    //     const hidden_t = Matrix.transpose(this.generatedHidden)\n    //     const weight_ho_deltas = Matrix.multiply(output_gradients, hidden_t)\n\n    //     this.weights_ho.add(weight_ho_deltas)\n    //     this.bias_o.add(output_gradients)\n\n    //     //Hidden gradient\n    //     const who_t = Matrix.transpose(this.weights_ho)\n    //     const hidden_errors: Matrix = Matrix.multiply(who_t, output_errors)\n\n    //     const hidden_gradients = Matrix.map(this.generatedHidden, dsigmoid)\n    //     hidden_gradients.multiply(hidden_errors)\n    //     hidden_gradients.scale(this.learningRate)\n\n    //     const inputs_t = Matrix.transpose(inputsM)\n    //     const weight_ih_deltas = Matrix.multiply(hidden_gradients, inputs_t)\n\n    //     this.weights_ih.add(weight_ih_deltas)\n    //     this.bias_h.add(hidden_gradients)\n    // }\n\n    train(input_array: number[], targets: number[]) {\n        const guess: number[] = this.predict(input_array)\n        const inputsM = Matrix.fromArray(input_array)\n        const guessM: Matrix = Matrix.fromArray(guess)\n\n        const targetsM: Matrix = Matrix.fromArray(targets)\n\n        //Output gradients\n        const output_errors: Matrix = Matrix.subtract(targetsM, guessM)\n\n        const output_gradients = Matrix.map(this.generatedOutputs, dsigmoid)\n        output_gradients.multiply(output_errors)\n        output_gradients.scale(this.learningRate)\n\n        const hidden_t = Matrix.transpose(this.hiddenLayers[this.hiddenLayers.length - 1])\n        const weight_ho_deltas = Matrix.multiply(output_gradients, hidden_t)\n\n        this.weights[this.weights.length - 1].add(weight_ho_deltas)\n        this.biases[this.biases.length - 1].add(output_gradients)\n\n        let hidden_errors_prev: Matrix = output_errors\n        let hidden_gradient_prev: Matrix = null\n\n        for (let i = this.hiddenLayers.length - 1; i > -1; i--) {\n            let weight_T: Matrix = Matrix.transpose(this.weights[i + 1])\n            hidden_errors_prev = Matrix.multiply(weight_T, hidden_errors_prev)\n\n            hidden_gradient_prev = Matrix.map(this.hiddenLayers[i], dsigmoid)\n            hidden_gradient_prev.multiply(hidden_errors_prev)\n            hidden_gradient_prev.scale(this.learningRate)\n\n            let next_layer_t = Matrix.transpose(i >= 1 ? this.hiddenLayers[i - 1] : inputsM)\n            let next_layer_deltas = Matrix.multiply(hidden_gradient_prev, next_layer_t)\n\n            this.weights[i].add(next_layer_deltas)\n            this.biases[i].add(hidden_gradient_prev)\n        }\n    }\n\n    // feedForward(input_array: number[]): number[] {\n    //     let inputs = Matrix.fromArray(input_array)\n\n    //     this.generatedHidden = Matrix.multiply(this.weights_ih, inputs)\n    //     this.generatedHidden.add(this.bias_h)\n    //     this.generatedHidden.map(sigmoid)\n\n    //     this.generatedOutputs = Matrix.multiply(this.weights_ho, this.generatedHidden)\n    //     this.generatedOutputs.add(this.bias_o)\n    //     this.generatedOutputs.map(sigmoid)\n\n    //     return Matrix.toFlatArray(this.generatedOutputs)\n    // }\n\n    predict(input_array: number[]): number[] {\n        let inputs = Matrix.fromArray(input_array)\n\n        for (let i = 0; i < this.hiddenLayerCount; i++) {\n            this.hiddenLayers[i] = Matrix.multiply(\n                this.weights[i],\n                i === 0 ? inputs : this.hiddenLayers[i - 1],\n            )\n            this.hiddenLayers[i].add(this.biases[i])\n            this.hiddenLayers[i].map(sigmoid)\n        }\n\n        this.generatedOutputs = Matrix.multiply(\n            this.weights[this.weights.length - 1],\n            this.hiddenLayers[this.hiddenLayerCount - 1],\n        )\n        this.generatedOutputs.add(this.biases[this.biases.length - 1])\n        this.generatedOutputs.map(sigmoid)\n\n        return Matrix.toFlatArray(this.generatedOutputs)\n    }\n\n    serialise = () => JSON.stringify(this)\n\n    static deserialise(data): NeuralNetwork {\n        let nn = new NeuralNetwork(data.inputs, data.hiddenLayerArray, data.outputs)\n        nn.hiddenLayers = data.hiddenLayers.map((layer) => Matrix.deserialise(layer))\n        nn.weights = data.weights.map((weight) => Matrix.deserialise(weight))\n        nn.biases = data.biases.map((bias) => Matrix.deserialise(bias))\n        nn.learningRate = data.learningRate\n        return nn\n    }\n}\n"],"names":["rows","columns","seed","this","console","table","_this","data","Array","fill","map","Matrix","input_array","length","cols","matrix","r","c","m","arr","push","column","Math","random","mod","cell","ridx","cidx","a","b","result","error","sum","k","func","newM","sigmoid","x","exp","dsigmoid","inputs","hiddenLayers","outputs","JSON","stringify","hiddenLayerArray","hiddenLayerCount","learningRate","weights","randomise","i","biases","weights_ho","bias_o","NeuralNetwork","targets","guess","predict","inputsM","fromArray","guessM","targetsM","output_errors","subtract","output_gradients","generatedOutputs","multiply","scale","hidden_t","transpose","weight_ho_deltas","add","hidden_errors_prev","hidden_gradient_prev","weight_T","next_layer_t","next_layer_deltas","toFlatArray","nn","layer","deserialise","weight","bias"],"mappings":"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"}